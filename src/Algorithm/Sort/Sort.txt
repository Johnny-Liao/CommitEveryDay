选择排序：
	直接选择排序：每次选择出最小的元素，依次放在最前面。								时间复杂度：O(n^2)			空间复杂度：O(1)					稳定：否
	堆排序：需要经过n-1次建堆，每次建堆的作用就是选出该堆中的最大值或最下值。				时间复杂度：O(nlog2n)		空间复杂度：O(1)					稳定：否

交换排序：
	冒泡排序：相邻两数据两两比较，把大数如泡泡般冒泡到最后；如果哪趟没发生交换则可提前结束。	时间复杂度：O(n^2)			空间复杂度：O(1)					稳定：是
	快速排序：把小于分界值的数置于左边，大于分界值的数置于右边。定位分界值的位置。			时间复杂度： 期望值：O(nlog2n) 最坏：O(n^2)	空间复杂度：O(log2n)	稳定：否
	
插入排序：
	直接插入排序：依次将待排序的数据元素按其关键值的大小插入前面的有序序列。				时间复杂度：O(n^2)			空间复杂度：O(1)					稳定：是
	折半插入排序：因为进行插入排序后前面的序列已经有序，所以可以折半比较。
	shell排序：增量插入排序、通过加大插入排序中元素的间隔，使有间隔的元素之间进行插入排序。	时间复杂度： 期望值：O(n^1.3)	 最坏：O(n^2)	空间复杂度：O(1)		稳定：否

归并排序：首先将长度为n的有序序列看成是n个长度为1的有序子序列，做二分操作，直到得到n/2长度为2的有序序列，再两两合并...合并为有序序列...
		不断重复此过程，最终得到长度为n的有序序列。								时间复杂度：O(nlog2n)		空间复杂度：O(1)		稳定：是

桶排序：

基数排序：	时间复杂度：d(n+k)	d:代表长度   n:代表关键字的个数   k:关键字的基数
	
	
